* prologue
* ch 1 - good parts
provides a nice testing ground file

I learned that the formatting of the '<pre>' tags is literal and puts some extra whitespace in if there is whitespace there.
* ch 2 grammar
** comments
block comments and single line comments. use single line comments to avoid problems with embedded symbols that might terminate block comments.
** names
plenty of reserved words, but otherwise seems to be the standard rules. starts with a letter and can have underscores and numbers inside.
** numbers
says here that all numbers are 64 bit doubles and that "A large class of numeric type errors is avoided." Unfortunately, I say, a large number of numeric errors is now possible. http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
numbers have methods though, and a math module to act on numbers.
** strings
single quotes or double quotes

backslash escape

all 16 bit chars, UTF-16? UCS2?

no character type, use single length strings.

strings are immutable, compared by contents, and have methods
** statements
compilation unit is made up of statements

each script tag is a compilation unit

when a script tag is encountered, it is immediately executed

all compilation units are in a global namespace, as there is no linker.

var statements for private variables


if switch while for do break return throw


has blocks, but blocks do not scope

labels

for conditionals, everything but falsy things is true, which includes random objects, etc.

false is :
 - false
 - null
 - undefined
 - empty string ''
 - number 0
 - number NaN

switch matches on strings and numbers (not objects)

while loop is standard

for loops have normal three clause form, as well as a foreach form as "for x in y"
gotcha on foreach form is to check object.hasOwnProperty(var) to make sure the object under test itself has the variable, and not a different object in the prototype chain (what is prototype chain?)

do while is standard

try catch seems to catch everything ? 

throw sends a whole object, by convention containing 'name' and 'message'

return can have a value or not. if it doesn't the value is 'undefined'.
no newline between return and the thing being returned.

break exits from loop or switch, as well as labeled blocks if given a label.

expression
 - assignment
 - invocation of method
 - delete object property

single '=' used for assignment
triple '===' used for comparison

literal values are expressions
invocation new
refinement delete
subexpression in parens
expression preceded by assignment
ternary '?'

operators have precedence

typeof returns a string

&& and || produce the value of the triggering operand, or the last if none.

invocation executes a function ()

refinement accesses a property or specific element of an object or array
this is dot references and [] reference

literals
- string
- number
- object
- array
- function
- regex

functions
have literals, with optional names for recursive calling
internal variable definitions

I really like the railroad diagrams.

* ch 3 objects
simple types are:
- numbers
- strings
- booleans
- null
- undefined
all other types are objects

 - numbers,
 -  strings
 -  booleans
 are immutable, but have methods

objects are mutable keyed collections
functions are objects, arrays ar objects, regexs are objects, and objects are objects

objects is container of properties, which are key-value pairs.

keys can be any string (even ''), values can be any object except for undefined

objects do not have classes. 

prototype linkage, allows one object to inherit the properties of another. (claim of reduced initialization and memory consumption)

** object literals.
create new objects
curly braces with key-value pairs separated by commas

key is any string, but does not necessarily need to be quoted. (probably best to always quote, I imagine)

objects can obviously nest

values retrieved with [], shortcut of using dot reference, similarly to unquoted strings for keys in creation

common paradigm of || used to return a default value

use paradigm of && for nullcheck

objects are mutable, so values can be updated. they can be created if they do not exist, or replaced if they do.

passed by reference. never copied.

** prototypes

all objects linked to a prototype Object.prototype

when making an object, it is possible to select the prototype.

provided create method creates a new object using an old object as prototype.

editing the original object edits the new object, but editing the new object does not edit the original object. 

this is a 'defaulting' lookup. if it doesn't exist on the current object, it looks in the parent prototype

this relationship is constant and dynamic. any change at a higher level affects all those at lower levels. 
** reflection
inspect an object by attempting to retrieve values. typeof can be used to check the values.

anything in the prototype chain can be found, including defaults like toString and constructor

paradigm of ignoring function values, because mainly data is what is being looked for.

other paradigm is using "hasOwnProperty" method which looks at only the current definition and not the prototype chain.


** enumeration
'for in' loops over all the keys in an object
commonly used with filters of hasOwnProperty and/or is not a function.

no guratneed order. so if wanted in an order, make an array, and iterate through that.

** delete 
deletes a key value pair

** keeping globals under control

make a single global variable for everything to be under.


